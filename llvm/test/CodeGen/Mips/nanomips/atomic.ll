; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=nanomips-unknown=elf --disable-machine-licm -verify-machineinstrs < %s | FileCheck %s

@x = common global i32 0, align 4

define i32 @AtomicLoadAdd32(i32 signext %incr) nounwind {
; CHECK-LABEL: AtomicLoadAdd32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    la $a2, x
; CHECK-NEXT:  .LBB0_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ll $a1, 0($a2)
; CHECK-NEXT:    addu $a3, $a1, $a0
; CHECK-NEXT:    sc $a3, 0($a2)
; CHECK-NEXT:    beqc $a3, $zero, .LBB0_1
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    move $a0, $a1
; CHECK-NEXT:    jrc $ra
entry:
  %0 = atomicrmw add i32* @x, i32 %incr monotonic
  ret i32 %0

}

define i32 @AtomicLoadSub32(i32 signext %incr) nounwind {
; CHECK-LABEL: AtomicLoadSub32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    la $a2, x
; CHECK-NEXT:  .LBB1_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ll $a1, 0($a2)
; CHECK-NEXT:    sub $a3, $a1, $a0
; CHECK-NEXT:    sc $a3, 0($a2)
; CHECK-NEXT:    beqc $a3, $zero, .LBB1_1
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    move $a0, $a1
; CHECK-NEXT:    jrc $ra
entry:
  %0 = atomicrmw sub i32* @x, i32 %incr monotonic
  ret i32 %0

}

define i32 @AtomicLoadXor32(i32 signext %incr) nounwind {
; CHECK-LABEL: AtomicLoadXor32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    la $a2, x
; CHECK-NEXT:  .LBB2_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ll $a1, 0($a2)
; CHECK-NEXT:    xor $a3, $a1, $a0
; CHECK-NEXT:    sc $a3, 0($a2)
; CHECK-NEXT:    beqc $a3, $zero, .LBB2_1
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    move $a0, $a1
; CHECK-NEXT:    jrc $ra
entry:
  %0 = atomicrmw xor i32* @x, i32 %incr monotonic
  ret i32 %0
}

define i32 @AtomicLoadOr32(i32 signext %incr) nounwind {
; CHECK-LABEL: AtomicLoadOr32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    la $a2, x
; CHECK-NEXT:  .LBB3_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ll $a1, 0($a2)
; CHECK-NEXT:    or $a3, $a1, $a0
; CHECK-NEXT:    sc $a3, 0($a2)
; CHECK-NEXT:    beqc $a3, $zero, .LBB3_1
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    move $a0, $a1
; CHECK-NEXT:    jrc $ra
entry:
  %0 = atomicrmw or i32* @x, i32 %incr monotonic
  ret i32 %0
}

define i32 @AtomicLoadAnd32(i32 signext %incr) nounwind {
; CHECK-LABEL: AtomicLoadAnd32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    la $a2, x
; CHECK-NEXT:  .LBB4_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ll $a1, 0($a2)
; CHECK-NEXT:    and $a3, $a1, $a0
; CHECK-NEXT:    sc $a3, 0($a2)
; CHECK-NEXT:    beqc $a3, $zero, .LBB4_1
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    move $a0, $a1
; CHECK-NEXT:    jrc $ra
entry:
  %0 = atomicrmw and i32* @x, i32 %incr monotonic
  ret i32 %0
}

define i32 @AtomicLoadNand32(i32 signext %incr) nounwind {
; CHECK-LABEL: AtomicLoadNand32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    la $a2, x
; CHECK-NEXT:  .LBB5_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ll $a1, 0($a2)
; CHECK-NEXT:    and $a3, $a1, $a0
; CHECK-NEXT:    nor $a3, $zero, $a3
; CHECK-NEXT:    sc $a3, 0($a2)
; CHECK-NEXT:    beqc $a3, $zero, .LBB5_1
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    move $a0, $a1
; CHECK-NEXT:    jrc $ra
entry:
  %0 = atomicrmw nand i32* @x, i32 %incr monotonic
  ret i32 %0

}

define i32 @AtomicSwap32(i32 signext %newval) nounwind {
; CHECK-LABEL: AtomicSwap32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    save 16
; CHECK-NEXT:    sw $a0, 12($sp)
; CHECK-NEXT:    la $a2, x
; CHECK-NEXT:  .LBB6_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ll $a1, 0($a2)
; CHECK-NEXT:    or $a3, $a0, $zero
; CHECK-NEXT:    sc $a3, 0($a2)
; CHECK-NEXT:    beqc $a3, $zero, .LBB6_1
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    move $a0, $a1
; CHECK-NEXT:    restore.jrc 16
entry:
  %newval.addr = alloca i32, align 4
  store i32 %newval, i32* %newval.addr, align 4
  %tmp = load i32, i32* %newval.addr, align 4
  %0 = atomicrmw xchg i32* @x, i32 %tmp monotonic
  ret i32 %0

}

define i32 @AtomicCmpSwap32(i32 signext %oldval, i32 signext %newval) nounwind {
; CHECK-LABEL: AtomicCmpSwap32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    save 16
; CHECK-NEXT:    sw $a1, 12($sp)
; CHECK-NEXT:    la $a3, x
; CHECK-NEXT:  .LBB7_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ll $a2, 0($a3)
; CHECK-NEXT:    bnec $a2, $a0, .LBB7_3
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    # in Loop: Header=BB7_1 Depth=1
; CHECK-NEXT:    move $a4, $a1
; CHECK-NEXT:    sc $a4, 0($a3)
; CHECK-NEXT:    beqc $a4, $zero, .LBB7_1
; CHECK-NEXT:  .LBB7_3: # %entry
; CHECK-NEXT:    move $a0, $a2
; CHECK-NEXT:    restore.jrc 16
entry:
  %newval.addr = alloca i32, align 4
  store i32 %newval, i32* %newval.addr, align 4
  %tmp = load i32, i32* %newval.addr, align 4
  %0 = cmpxchg i32* @x, i32 %oldval, i32 %tmp monotonic monotonic
  %1 = extractvalue { i32, i1 } %0, 0
  ret i32 %1

}

@y = common global i8 0, align 1

define signext i8 @AtomicLoadAdd8(i8 signext %incr) nounwind {
; CHECK-LABEL: AtomicLoadAdd8:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    la $a1, y
; CHECK-NEXT:    addiu $a2, $zero, -4
; CHECK-NEXT:    and $a4, $a1, $a2
; CHECK-NEXT:    andi $a1, $a1, 3
; CHECK-NEXT:    sll $a7, $a1, 3
; CHECK-NEXT:    ori $a3, $zero, 255
; CHECK-NEXT:    sllv $a6, $a3, $a7
; CHECK-NEXT:    nor $a5, $zero, $a6
; CHECK-NEXT:    sllv $a2, $a0, $a7
; CHECK-NEXT:  .LBB8_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ll $a3, 0($a4)
; CHECK-NEXT:    addu $a1, $a3, $a2
; CHECK-NEXT:    and $a1, $a1, $a6
; CHECK-NEXT:    and $t0, $a3, $a5
; CHECK-NEXT:    or $t0, $t0, $a1
; CHECK-NEXT:    sc $t0, 0($a4)
; CHECK-NEXT:    beqc $t0, $zero, .LBB8_1
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    and $a0, $a3, $a6
; CHECK-NEXT:    srlv $a0, $a0, $a7
; CHECK-NEXT:    seb $a0, $a0
; CHECK-NEXT:  # %bb.3: # %entry
; CHECK-NEXT:    jrc $ra
entry:
  %0 = atomicrmw add i8* @y, i8 %incr monotonic
  ret i8 %0
}

define signext i8 @AtomicLoadSub8(i8 signext %incr) nounwind {
; CHECK-LABEL: AtomicLoadSub8:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    la $a1, y
; CHECK-NEXT:    addiu $a2, $zero, -4
; CHECK-NEXT:    and $a4, $a1, $a2
; CHECK-NEXT:    andi $a1, $a1, 3
; CHECK-NEXT:    sll $a7, $a1, 3
; CHECK-NEXT:    ori $a3, $zero, 255
; CHECK-NEXT:    sllv $a6, $a3, $a7
; CHECK-NEXT:    nor $a5, $zero, $a6
; CHECK-NEXT:    sllv $a2, $a0, $a7
; CHECK-NEXT:  .LBB9_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ll $a3, 0($a4)
; CHECK-NEXT:    subu $a1, $a3, $a2
; CHECK-NEXT:    and $a1, $a1, $a6
; CHECK-NEXT:    and $t0, $a3, $a5
; CHECK-NEXT:    or $t0, $t0, $a1
; CHECK-NEXT:    sc $t0, 0($a4)
; CHECK-NEXT:    beqc $t0, $zero, .LBB9_1
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    and $a0, $a3, $a6
; CHECK-NEXT:    srlv $a0, $a0, $a7
; CHECK-NEXT:    seb $a0, $a0
; CHECK-NEXT:  # %bb.3: # %entry
; CHECK-NEXT:    jrc $ra
entry:
  %0 = atomicrmw sub i8* @y, i8 %incr monotonic
  ret i8 %0

}

define signext i8 @AtomicLoadNand8(i8 signext %incr) nounwind {
; CHECK-LABEL: AtomicLoadNand8:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    la $a1, y
; CHECK-NEXT:    addiu $a2, $zero, -4
; CHECK-NEXT:    and $a4, $a1, $a2
; CHECK-NEXT:    andi $a1, $a1, 3
; CHECK-NEXT:    sll $a7, $a1, 3
; CHECK-NEXT:    ori $a3, $zero, 255
; CHECK-NEXT:    sllv $a6, $a3, $a7
; CHECK-NEXT:    nor $a5, $zero, $a6
; CHECK-NEXT:    sllv $a2, $a0, $a7
; CHECK-NEXT:  .LBB10_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ll $a3, 0($a4)
; CHECK-NEXT:    and $a1, $a3, $a2
; CHECK-NEXT:    nor $a1, $zero, $a1
; CHECK-NEXT:    and $a1, $a1, $a6
; CHECK-NEXT:    and $t0, $a3, $a5
; CHECK-NEXT:    or $t0, $t0, $a1
; CHECK-NEXT:    sc $t0, 0($a4)
; CHECK-NEXT:    beqc $t0, $zero, .LBB10_1
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    and $a0, $a3, $a6
; CHECK-NEXT:    srlv $a0, $a0, $a7
; CHECK-NEXT:    seb $a0, $a0
; CHECK-NEXT:  # %bb.3: # %entry
; CHECK-NEXT:    jrc $ra
entry:
  %0 = atomicrmw nand i8* @y, i8 %incr monotonic
  ret i8 %0

}

define signext i8 @AtomicSwap8(i8 signext %newval) nounwind {
; CHECK-LABEL: AtomicSwap8:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    la $a1, y
; CHECK-NEXT:    addiu $a2, $zero, -4
; CHECK-NEXT:    and $a4, $a1, $a2
; CHECK-NEXT:    andi $a1, $a1, 3
; CHECK-NEXT:    sll $a7, $a1, 3
; CHECK-NEXT:    ori $a3, $zero, 255
; CHECK-NEXT:    sllv $a6, $a3, $a7
; CHECK-NEXT:    nor $a5, $zero, $a6
; CHECK-NEXT:    sllv $a2, $a0, $a7
; CHECK-NEXT:  .LBB11_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ll $a3, 0($a4)
; CHECK-NEXT:    and $a1, $a2, $a6
; CHECK-NEXT:    and $t0, $a3, $a5
; CHECK-NEXT:    or $t0, $t0, $a1
; CHECK-NEXT:    sc $t0, 0($a4)
; CHECK-NEXT:    beqc $t0, $zero, .LBB11_1
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    and $a0, $a3, $a6
; CHECK-NEXT:    srlv $a0, $a0, $a7
; CHECK-NEXT:    seb $a0, $a0
; CHECK-NEXT:  # %bb.3: # %entry
; CHECK-NEXT:    jrc $ra
entry:
  %0 = atomicrmw xchg i8* @y, i8 %newval monotonic
  ret i8 %0
}

define signext i8 @AtomicCmpSwap8(i8 signext %oldval, i8 signext %newval) nounwind {
; CHECK-LABEL: AtomicCmpSwap8:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    la $a2, y
; CHECK-NEXT:    addiu $a3, $zero, -4
; CHECK-NEXT:    and $a4, $a2, $a3
; CHECK-NEXT:    andi $a2, $a2, 3
; CHECK-NEXT:    sll $t0, $a2, 3
; CHECK-NEXT:    ori $a3, $zero, 255
; CHECK-NEXT:    sllv $a7, $a3, $t0
; CHECK-NEXT:    nor $a5, $zero, $a7
; CHECK-NEXT:    andi $a0, $a0, 255
; CHECK-NEXT:    sllv $a6, $a0, $t0
; CHECK-NEXT:    andi $a0, $a1, 255
; CHECK-NEXT:    sllv $a1, $a0, $t0
; CHECK-NEXT:  .LBB12_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ll $a3, 0($a4)
; CHECK-NEXT:    and $a2, $a3, $a7
; CHECK-NEXT:    bnec $a2, $a6, .LBB12_3
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    # in Loop: Header=BB12_1 Depth=1
; CHECK-NEXT:    and $a3, $a3, $a5
; CHECK-NEXT:    or $a3, $a3, $a1
; CHECK-NEXT:    sc $a3, 0($a4)
; CHECK-NEXT:    beqc $a3, $zero, .LBB12_1
; CHECK-NEXT:  .LBB12_3: # %entry
; CHECK-NEXT:    srlv $a0, $a2, $t0
; CHECK-NEXT:    seb $a0, $a0
; CHECK-NEXT:  # %bb.4: # %entry
; CHECK-NEXT:    jrc $ra
entry:
  %pair0 = cmpxchg i8* @y, i8 %oldval, i8 %newval monotonic monotonic
  %0 = extractvalue { i8, i1 } %pair0, 0
  ret i8 %0
}

define i1 @AtomicCmpSwapRes8(i8* %ptr, i8 signext %oldval, i8 signext %newval) nounwind {
; CHECK-LABEL: AtomicCmpSwapRes8:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addiu $a3, $zero, -4
; CHECK-NEXT:    and $a4, $a0, $a3
; CHECK-NEXT:    andi $a0, $a0, 3
; CHECK-NEXT:    sll $t0, $a0, 3
; CHECK-NEXT:    ori $a0, $zero, 255
; CHECK-NEXT:    sllv $a5, $a0, $t0
; CHECK-NEXT:    nor $a6, $zero, $a5
; CHECK-NEXT:    andi $a0, $a1, 255
; CHECK-NEXT:    sllv $a7, $a0, $t0
; CHECK-NEXT:    andi $a0, $a2, 255
; CHECK-NEXT:    sllv $a2, $a0, $t0
; CHECK-NEXT:  .LBB13_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ll $a3, 0($a4)
; CHECK-NEXT:    and $t1, $a3, $a5
; CHECK-NEXT:    bnec $t1, $a7, .LBB13_3
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    # in Loop: Header=BB13_1 Depth=1
; CHECK-NEXT:    and $a3, $a3, $a6
; CHECK-NEXT:    or $a3, $a3, $a2
; CHECK-NEXT:    sc $a3, 0($a4)
; CHECK-NEXT:    beqc $a3, $zero, .LBB13_1
; CHECK-NEXT:  .LBB13_3: # %entry
; CHECK-NEXT:    srlv $a0, $t1, $t0
; CHECK-NEXT:    seb $a0, $a0
; CHECK-NEXT:  # %bb.4: # %entry
; CHECK-NEXT:    xor $a0, $a0, $a1
; CHECK-NEXT:    sltiu $a0, $a0, 1
; CHECK-NEXT:    jrc $ra
entry:
  %0 = cmpxchg i8* %ptr, i8 %oldval, i8 %newval monotonic monotonic
  %1 = extractvalue { i8, i1 } %0, 1
  ret i1 %1

}

@z = common global i16 0, align 1

define signext i16 @AtomicLoadAdd16(i16 signext %incr) nounwind {
; CHECK-LABEL: AtomicLoadAdd16:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    la $a1, z
; CHECK-NEXT:    addiu $a2, $zero, -4
; CHECK-NEXT:    and $a4, $a1, $a2
; CHECK-NEXT:    andi $a1, $a1, 3
; CHECK-NEXT:    sll $a7, $a1, 3
; CHECK-NEXT:    ori $a3, $zero, 4095
; CHECK-NEXT:    sllv $a6, $a3, $a7
; CHECK-NEXT:    nor $a5, $zero, $a6
; CHECK-NEXT:    sllv $a2, $a0, $a7
; CHECK-NEXT:  .LBB14_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ll $a3, 0($a4)
; CHECK-NEXT:    addu $a1, $a3, $a2
; CHECK-NEXT:    and $a1, $a1, $a6
; CHECK-NEXT:    and $t0, $a3, $a5
; CHECK-NEXT:    or $t0, $t0, $a1
; CHECK-NEXT:    sc $t0, 0($a4)
; CHECK-NEXT:    beqc $t0, $zero, .LBB14_1
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    and $a0, $a3, $a6
; CHECK-NEXT:    srlv $a0, $a0, $a7
; CHECK-NEXT:    seh $a0, $a0
; CHECK-NEXT:  # %bb.3: # %entry
; CHECK-NEXT:    jrc $ra
entry:
  %0 = atomicrmw add i16* @z, i16 %incr monotonic
  ret i16 %0

}

define {i16, i1} @foo(i16* %addr, i16 %l, i16 %r, i16 %new) {
; CHECK-LABEL: foo:
; CHECK:       # %bb.0:
; CHECK-NEXT:    save 16, $s0
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    .cfi_offset 16, -4
; CHECK-NEXT:    addu $s0, $a1, $a2
; CHECK-NEXT:    sync
; CHECK-NEXT:    addiu $a2, $zero, -4
; CHECK-NEXT:    and $a4, $a0, $a2
; CHECK-NEXT:    andi $a0, $a0, 3
; CHECK-NEXT:    sll $t1, $a0, 3
; CHECK-NEXT:    ori $a0, $zero, 4095
; CHECK-NEXT:    sllv $t0, $a0, $t1
; CHECK-NEXT:    nor $a6, $zero, $t0
; CHECK-NEXT:    andi $a0, $s0, 65535
; CHECK-NEXT:    sllv $a7, $a0, $t1
; CHECK-NEXT:    andi $a0, $a3, 65535
; CHECK-NEXT:    sllv $a3, $a0, $t1
; CHECK-NEXT:  .LBB15_1: # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ll $a1, 0($a4)
; CHECK-NEXT:    and $a2, $a1, $t0
; CHECK-NEXT:    bnec $a2, $a7, .LBB15_3
; CHECK-NEXT:  # %bb.2: # in Loop: Header=BB15_1 Depth=1
; CHECK-NEXT:    and $a1, $a1, $a6
; CHECK-NEXT:    or $a1, $a1, $a3
; CHECK-NEXT:    sc $a1, 0($a4)
; CHECK-NEXT:    beqc $a1, $zero, .LBB15_1
; CHECK-NEXT:  .LBB15_3:
; CHECK-NEXT:    srlv $a0, $a2, $t1
; CHECK-NEXT:    seh $a0, $a0
; CHECK-NEXT:  # %bb.4:
; CHECK-NEXT:    seh $a1, $s0
; CHECK-NEXT:    xor $a1, $a0, $a1
; CHECK-NEXT:    sltiu $a1, $a1, 1
; CHECK-NEXT:    sync
; CHECK-NEXT:    restore.jrc 16, $s0
  %desired = add i16 %l, %r
  %res = cmpxchg i16* %addr, i16 %desired, i16 %new seq_cst seq_cst
  ret {i16, i1} %res
}

@countsint = common global i32 0, align 4

define i32 @CheckSync(i32 signext %v) nounwind noinline {
; CHECK-LABEL: CheckSync:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sync
; CHECK-NEXT:    la $a2, countsint
; CHECK-NEXT:  .LBB16_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ll $a1, 0($a2)
; CHECK-NEXT:    addu $a3, $a1, $a0
; CHECK-NEXT:    sc $a3, 0($a2)
; CHECK-NEXT:    beqc $a3, $zero, .LBB16_1
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    sync
; CHECK-NEXT:    move $a0, $a1
; CHECK-NEXT:    jrc $ra
entry:
  %0 = atomicrmw add i32* @countsint, i32 %v seq_cst
  ret i32 %0
}

@a = external global i32

define i32 @zeroreg() nounwind {
; CHECK-LABEL: zeroreg:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sync
; CHECK-NEXT:    li $a0, 1
; CHECK-NEXT:    la $a1, a
; CHECK-NEXT:  .LBB17_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ll $a2, 0($a1)
; CHECK-NEXT:    bnec $a2, $a0, .LBB17_3
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    # in Loop: Header=BB17_1 Depth=1
; CHECK-NEXT:    move $a3, $zero
; CHECK-NEXT:    sc $a3, 0($a1)
; CHECK-NEXT:    beqc $a3, $zero, .LBB17_1
; CHECK-NEXT:  .LBB17_3: # %entry
; CHECK-NEXT:    seqi $a0, $a2, 1
; CHECK-NEXT:    sync
; CHECK-NEXT:    jrc $ra
entry:
  %pair0 = cmpxchg i32* @a, i32 1, i32 0 seq_cst seq_cst
  %0 = extractvalue { i32, i1 } %pair0, 0
  %1 = icmp eq i32 %0, 1
  %conv = zext i1 %1 to i32
  ret i32 %conv
}

define i32 @AtomicLoadAdd32_OffGt9Bit(i32 signext %incr) nounwind {
; CHECK-LABEL: AtomicLoadAdd32_OffGt9Bit:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    la $a2, x+1024
; CHECK-NEXT:  .LBB18_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ll $a1, 0($a2)
; CHECK-NEXT:    addu $a3, $a1, $a0
; CHECK-NEXT:    sc $a3, 0($a2)
; CHECK-NEXT:    beqc $a3, $zero, .LBB18_1
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    move $a0, $a1
; CHECK-NEXT:    jrc $ra
entry:
  %0 = atomicrmw add i32* getelementptr(i32, i32* @x, i32 256), i32 %incr monotonic
  ret i32 %0

}
